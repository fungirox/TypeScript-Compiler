180 X → Ɛ
PPAL
0 PPAL → PP0 { STATUS PP5 }
1 PP0 → INTERF PP0
2 PP0 → CLASE PP0
3 PP0 → LET PP1 PP2
4 PP0 -> DEC_FUN PP3
5 PP1 -> ; LET PP1
6 PP2 -> DEC_FUN PP4
7 PP3 -> ; DEC_FUN PP3
8 PP4 -> ; DEC_FUN PP4 
9 PP5 -> ; STATUS PP5


CLASE 
11 CLASE → class id { DEC_VAR E0 DEC_MET E1 }
12 E0 → ; DEC_VAR E0
13 E1 → DEC_MET E1


DEC_FUN 
14 DEC_FUN → fuction id ( DEC_VAR F0 ) F1 { STATUS F2 }
15 F0 → , DEC_VAR F0
16 F1 → : TIPO
17 F2 → ; STATUS F2


DEC_GET_SET
18 GS → set id ( DEC_VAR G0 ) { STATUS G1 }
19 G0 → , DEC_VAR G0
20 G1 → ; STATUS G1
21 GS → get id ( ) : TIPO { STATUS G2 }
22 G2 → ; STATUS G2


TIPO
23 TIPO → string
24 TIPO → number
25 TIPO → boolean
26 TIPO → null
27 TIPO → real
28 TIPO -> # id 


CONSTIPO
29 CT → cadena
30 CT → numerica
31 CT → true
32 CT → false
33 CT → real
34 CT → null

LET
35 LET → let id T0
36 T0 → = T1
37 T1 → fuction ( DEC_VAR T2 ) T3 { STATUS T4 }
38 T2 → , DEC_VAR T2
39 T3 → : TIPO
40 T4 → ; STATUS T4
41 T1 → ( DEC_VAR T5 ) = > STATUS
42 T5 → , DEC_VAR T5
43 T0 → : T6
44 T6 → Array <T7> = T8
45 T7 → TIPO 
46 T7 → id
47 T8 → [ T9 ] 
48 T9 → OR T10 
49 T10 → , OR T10 
50 T8 → new Array ()
51 T6 → TIPO T11
52 T11 → = T12
53 T12 → CONSTIPO
54 T12 → { DEC_VAR , T13 DEC_GET_SET T14 DEC_MET T15 }
55 T13 → DEC_VAR ,
56 T14 → , DEC_GET_SET
57 T15 → , DEC_MET
58 T6 → id T16
59 T16 → = T17
60 T17 → CONSTIPO
61 T17 → { DEC_VAR , T18 DEC_GET_SET T19 DEC_MET T20 }
62 T18 → DEC_VAR ,
63 T19 → , DEC_GET_SET
64 T20 → , DEC_MET
65 T16 → T21 < TIPO , TIPO > = T22
66 T21 → Map 
67 T22 → new Map ()
68 T22 → [ T23 ]
69 T23 → OR T24
70 T24 → , OR T24

DEC_VAR
71 DEC_VAR → id : TIPO 

INTERF
72 INTERF → interface id { DEC_VAR H0 }
73 H0 → ; DEC_VAR H0

DEC_MET
74 DM → id ( DEC_VAR I0 ) I1 { STATUS I2 }
75 I0 → , DEC_VAR I0
76 I1 → : TIPO
77 I2 → ; STATUS I2

ASIG 
78 AS → =
79 AS → +=
80 AS → /=
81 AS → *=
82 AS → -=
83 AS → %=
84 AS → &=
85 AS → ^=
86 AS → <<=
87 AS → >>=
88 AS → >>>=

STATUS
89 STATUS → Console . S0
90 STATUS → if ( OR ) STATUS S2
91 STATUS → switch ( OR ) { case OR : S3 STATUS S4 break S5 }
92 STATUS → { STATUS S8 }
93 STATUS → while ( OR ) STATUS
94 STATUS → OR ;
95 STATUS → return OR ;
96 STATUS → do STATUS while ( OR ) ; 
97 STATUS → for ( S9 ) STATUS
98 S0 → read ( OR S1 )
99 S0 → log ( OR )
100 S1 → , OR S1
101 S2 → else OR
102 S3 → case OR : S3
103 S4 → ; STATUS S4
104 S5 → case OR : S13 break S5
105 S5 → default : STATUS S7
106 S6 → ; STATUS S6
107 S7 → ; STATUS S7
108 S8 → ; STATUS S8
109 S9 → OR S10 ; STATUS ; OR S11
110 S9 → let id S12 id 
111 S10 → , OR S10
112 S11 → , OR S11
113 S12 → in
114 S12 → of
115 S13 → STATUS S6

MET_CAD
116 MC → toLowerCase()
117 MC → toUpperCase()
118 MC → legth
119 MC → trim()
120 MC → charAt(OR)
121 MC → startsWith(OR)
122 MC → endsWith(OR)
123 MC → indexOf(OR)
124 MC → includes(OR)
125 MC → slice(OR,OR)
126 MC → replace(OR,OR)
127 MC → split(OR)

FUNCION 
128 FUN → expo ( OR , OR )
129 FUN → sqrtv ( OR , OR )
130 FUN → ConvBase ( OR , OR , )
131 FUN → asc ( OR )
132 FUN → sen ( OR )
133 FUN → val ( OR )
134 FUN → cos ( OR )
135 FUN → tan ( OR )
136 FUN → MET_CAD

ARR 
137 ARR → [ OR D0 ]
138 D0 → , OR D0

OR
139 OR → AND L0
140 L0 → || AND L0
141 L0 → | AND L0


AND
142 AND → EXP_PAS M0
143 M0 → && EXP_PAS M0
144 M0 → & EXP_PAS M0
145 M0 → ^ EXP_PAS M0


EXP_PAS
146 EXP_PAS → SEP EXP0
147 EXP0 → < SEP EXP0
148 EXP0 → <= SEP EXP0
149 EXP0 → == SEP EXP0
150 EXP0 → != SEP EXP0
151 EXP0 → >= SEP EXP0
152 EXP0 → > SEP EXP0
153 EXP0 → === SEP EXP0
154 EXP0 → !== SEP EXP0

SIMPLE EXP_PAS
155 SEP → TMP SEP1 
156 SEP1 → - TMP SEP1
157 SEP1 → + TMP SEP1
158 SEP1 → << TMP SEP1
159 SEP1 → >> TMP SEP1
160 SEP1 → >>> TMP SEP1


TERMINO PASCAL
161 TMP → ELEV K0
162 K0 → * ELEV K0
163 K0 → / ELEV K0
164 K0 → % ELEV K0

ELEVACION
165 ELEV → FACTOR J0
166 J0 → ** FACTOR J0


FACTOR 
167 FA → CONSTIPO 
168 FA → FA0 id FA1
169 FA → FA6 ( OR )
170 FA → FUNCION
171 FA0 → ++
172 FA0 → --
173 FA1 → ARR FA2
174 FA1 → ( FA4 )
175 FA1 -> ASIG OR FA3 
176 FA2 → ASIG OR FA3
177 FA3 → ? OR : OR 
178 FA4 → OR FA5
179 FA5 → , OR FA5 
180 FA6 → !
181 FA6 → ~

